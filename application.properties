memberController.java
package com.cts.controller;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.cts.memberDTO.MemberDto;
import com.cts.model.Member;
import com.cts.service.MemberService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RestController
@RequestMapping("/members")
@RequiredArgsConstructor
@Slf4j
@Validated
public class MemberController {

    @Autowired
    private MemberService memberService;

    @PostMapping("/regMember")
    public Member registerMember(@RequestBody Member member) {
        log.info("POST /members");
        return memberService.registerMember(member);
    }

    @PutMapping("update/{id}")
    public Member updateMember(@PathVariable Long id, @Valid @RequestBody Member member) {
        log.info("PUT /members/{}", id);
        return memberService.updateMember(id, member);
    }

    @GetMapping("/email/{email}")
    public ResponseEntity<MemberDto> getMemberByEmail(@PathVariable String email) {
        MemberDto memberDto = memberService.getMemberByEmail(email);
        return new ResponseEntity<>(memberDto, HttpStatus.OK);
    }
    
    @GetMapping("/getallMember")
	public List<Member> getAllMember() {
		return memberService.getAllMember();
	}


    @GetMapping("/{memberId}")
    public Member getMemberById(@PathVariable Long memberId) {
        log.info("GET /members/{}", memberId);
        return memberService.getMemberById(memberId);
    }
    
    @DeleteMapping("/delete/{id}")
    public ResponseEntity<String> deleteMember(@PathVariable Long id) {
        memberService.deleteById(id);
        return ResponseEntity.ok("Member deleted successfully");
    }
}

BorrowingServiceImpl.java
@Override
	public BorrowingTransaction borrowBook(BorrowingTransactionDTO transactionDTO) {
		logger.info("Attempting to borrow book with ID: {} for member ID: {}", transactionDTO.getBookId(),
				transactionDTO.getMemberId());

		// Validate member and book
		memberClient.getMember(transactionDTO.getMemberId()); // Ensure member exists
		bookClient.getBook(transactionDTO.getBookId()); // Ensure book exists

		// Check for borrowing limit
		long activeBorrowings = repository
				.findByMemberIdAndStatus(transactionDTO.getMemberId(), BorrowingTransaction.Status.BORROWED).size();
		if (activeBorrowings >= 5) {
			logger.warn("Borrowing limit exceeded for member ID: {}", transactionDTO.getMemberId());
			throw new BorrowingNotAllowedException("Borrowing limit exceeded");
		}

		// Check if the same book is already borrowed by the same member
		boolean alreadyBorrowedSameBook = repository.findByBookIdAndMemberIdAndStatus(transactionDTO.getBookId(),
				transactionDTO.getMemberId(), BorrowingTransaction.Status.BORROWED).isPresent();

		if (alreadyBorrowedSameBook) {
			logger.warn("Member ID: {} is already borrowing Book ID: {}", transactionDTO.getMemberId(),
					transactionDTO.getBookId());
			throw new BorrowingNotAllowedException("Book is already borrowed by this member");
		}

		// Create new borrowing transaction
		BorrowingTransaction tx = BorrowingTransaction.builder().bookId(transactionDTO.getBookId())
				.memberId(transactionDTO.getMemberId()).borrowDate(LocalDate.now())
				.status(BorrowingTransaction.Status.BORROWED).build();

		repository.save(tx);
		log.info("New Borrowing is done");
		String msg = "Successfully borrowed Book ID: " + transactionDTO.getBookId() + " by Member ID: "
				+ transactionDTO.getMemberId();
		mailClient.sendEmail("recipient@example.com", "Library Book Borrowed", msg);
		return tx;
	}

	@Override
	public List<BorrowingTransaction> getAllBorrows() {
		log.debug("Fetching all Borrows");
		return repository.findAll();
	}

	@Override
	public BorrowingTransaction returnBook(Long memberId, Long bookId) {
		logger.info("Attempting to return book with ID: {} for member ID: {}", bookId, memberId);

		BorrowingTransaction tx = repository
				.findByBookIdAndMemberIdAndStatus(bookId, memberId, BorrowingTransaction.Status.BORROWED)
				.orElseThrow(() -> {
					logger.error("No active borrowing found for book ID: {} and member ID: {}", bookId, memberId);
					return new BorrowingTransactionNotFoundException("No active borrowing found");
				});

		tx.setStatus(BorrowingTransaction.Status.RETURNED);
		tx.setReturnDate(LocalDate.now());
		repository.save(tx);

		logger.info("Book returned successfully: Book ID={}, Member ID={}", bookId, memberId);
		return tx;
	}

MemberClient.java
package com.cts.feign;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;

import com.cts.dto.MemberDTO;

@FeignClient(name = "MEMBERSERVICE", path="/members")
public interface MemberClient {
    @GetMapping("/{id}")
    Object getMember(@PathVariable Long id);
    
}
