
Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
[2m2025-06-07T12:26:23.780+05:30[0;39m [31mERROR[0;39m [35m17556[0;39m [2m--- [BorrowingService] [  restartedMain] [0;39m[36mo.s.b.d.LoggingFailureAnalysisReporter  [0;39m [2m:[0;39m 

***************************
APPLICATION FAILED TO START
***************************

Description:

Parameter 0 of method modifyRequestBodyGatewayFilterFactory in org.springframework.cloud.gateway.config.GatewayAutoConfiguration required a bean of type 'org.springframework.http.codec.ServerCodecConfigurer' that could not be found.


Action:

Consider defining a bean of type 'org.springframework.http.codec.ServerCodecConfigurer' in your configuration.

package com.cts;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class BorrowingServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(BorrowingServiceApplication.class, args);
	}

}


package com.cts.controller;

import java.util.List;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.cts.model.BorrowingTransaction;
import com.cts.service.BorrowingService;

import lombok.AllArgsConstructor;

@RestController
@AllArgsConstructor
@RequestMapping("/borrowings")
public class BorrowingController {

	private final BorrowingService borrowingService;
	
	//Borrow Book
	@PostMapping("/borrow/{bookId}")
	public BorrowingTransaction borrowBook(@PathVariable Long bookId, @RequestHeader("Authorization") String token) {
		return borrowingService.borrowBook(bookId, token);
	}

	//return Book
	@PutMapping("/return/{bookId}")
	public BorrowingTransaction returnBook(@PathVariable Long bookId, @RequestHeader("Authorization") String token) {
		return borrowingService.returnBook(bookId, token);
	}

	// Get all currently borrowed books by a member
	@GetMapping("/{memberId}")
	public List<BorrowingTransaction> getBorrowedBooks(@PathVariable Long memberId) {
		return borrowingService.getMemberBorrowedBooks(memberId);
	}

	// get all borrowed books
	@GetMapping("/getall")
	public List<BorrowingTransaction> getAllBorrows() {
		return borrowingService.getAllBorrows();
	}
}

package com.cts.service;

import java.util.List;

import com.cts.dto.BorrowingTransactionDTO;
import com.cts.model.BorrowingTransaction;

public interface BorrowingService {

	BorrowingTransaction borrowBook(Long bookId, String token);

	BorrowingTransaction returnBook(Long bookId, String token);	

	List<BorrowingTransaction> getMemberBorrowedBooks(Long memberId);
	
	List<BorrowingTransaction> getAllBorrows();
}

package com.cts.service;

import java.time.LocalDate;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import com.cts.dto.MemberDTO;
import com.cts.exception.BorrowingNotAllowedException;
import com.cts.exception.BorrowingTransactionNotFoundException;
import com.cts.feign.BookClient;
import com.cts.feign.MailClient;
//import com.cts.feign.MailClient;
import com.cts.feign.MemberClient;
import com.cts.model.BorrowingTransaction;
import com.cts.repository.BorrowingRepository;
import com.cts.util.JwtUtil;

import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@AllArgsConstructor
public class BorrowingServiceImpl implements BorrowingService {

	private static final Logger logger = LoggerFactory.getLogger(BorrowingServiceImpl.class);

	private final BorrowingRepository repository;
	private final BookClient bookClient;
	private final MemberClient memberClient;
	private final MailClient mailClient;
	private JwtUtil jwtUtil;

	@Override
	public BorrowingTransaction borrowBook(Long bookId, String token) {
		String email = jwtUtil.extractEmailFromToken(token);
		MemberDTO member = memberClient.getMemberByEmail(email);
		Long memberId = member.getMemberId();

		logger.info("Attempting to borrow book ID: {} for member ID: {}", bookId, memberId);

		memberClient.getMember(memberId); // ensure member exists
		bookClient.getBook(bookId); // ensure book exists

		long activeBorrowings = repository.findByMemberIdAndStatus(memberId, BorrowingTransaction.Status.BORROWED)
				.size();

		if (activeBorrowings >= 5) {
			throw new BorrowingNotAllowedException("Borrowing limit exceeded");
		}

		boolean alreadyBorrowedSameBook = repository
				.findByBookIdAndMemberIdAndStatus(bookId, memberId, BorrowingTransaction.Status.BORROWED).isPresent();

		if (alreadyBorrowedSameBook) {
			throw new BorrowingNotAllowedException("Book is already borrowed by this member");
		}

		BorrowingTransaction tx = BorrowingTransaction.builder().bookId(bookId).memberId(memberId)
				.borrowDate(LocalDate.now()).status(BorrowingTransaction.Status.BORROWED).build();

		repository.save(tx);
		log.info("Borrow transaction successful");

		String msg = "Successfully borrowed Book ID: " + bookId + " by Member ID: " + memberId;
		mailClient.sendEmail("recipient@example.com", "Library Book Borrowed", msg);

		return tx;
	}

	@Override
	public List<BorrowingTransaction> getAllBorrows() {
		log.debug("Fetching all Borrows");
		return repository.findAll();
	}

	@Override
	public BorrowingTransaction returnBook(Long bookId, String token) {
		String email = jwtUtil.extractEmailFromToken(token);
		MemberDTO member = memberClient.getMemberByEmail(email);
		Long memberId = member.getMemberId();

		logger.info("Attempting to return book ID: {} for member ID: {}", bookId, memberId);

		BorrowingTransaction tx = repository
				.findByBookIdAndMemberIdAndStatus(bookId, memberId, BorrowingTransaction.Status.BORROWED)
				.orElseThrow(() -> new BorrowingTransactionNotFoundException("No active borrowing found"));

		tx.setStatus(BorrowingTransaction.Status.RETURNED);
		tx.setReturnDate(LocalDate.now());
		repository.save(tx);

		logger.info("Book returned successfully: Book ID={}, Member ID={}", bookId, memberId);
		return tx;
	}

	@Override
	public List<BorrowingTransaction> getMemberBorrowedBooks(Long memberId) {
		logger.debug("Fetching borrowed books for member ID: {}", memberId);

		List<BorrowingTransaction> borrowedBooks = repository.findByMemberIdAndStatus(memberId,
				BorrowingTransaction.Status.BORROWED);

		logger.info("Retrieved {} borrowed books for member ID: {}", borrowedBooks.size(), memberId);
		return borrowedBooks;
	}

}
