<app-navbar></app-navbar>
<div class="container">
  <div class="text-center mt-3 mb-4">
    <h2 class="mb-2 text-primary">üìö Book Module</h2>
    <p class="text-muted">Manage all book-related operations</p>
  </div>

  <!-- üîç Search -->
  <div class="row mb-4 align-items-center">
    <div class="col-md-4">
      <select class="form-select" [(ngModel)]="searchType">
        <option value="title">Search by Title</option>
        <option value="author">Search by Author</option>
        <option value="genre">Search by Genre</option>
      </select>
    </div>
    <div class="col-md-6">
      <input type="text" class="form-control" placeholder="Enter search term" [(ngModel)]="searchValue" />
    </div>
    <div class="col-md-2">
      <button class="btn btn-primary w-100" (click)="searchBooks()">
        <i class="bi bi-search"></i> Search
      </button>
    </div>
  </div>

  <!-- üìö Book Cards -->
  <div class="row">
    <ng-container *ngFor="let book of books; trackBy: trackById">
      <div class="col-sm-6 col-md-4 col-lg-3 mb-4 d-flex">
        <div class="card shadow w-100 text-center">
          <img src="https://tse1.mm.bing.net/th/id/OIP.li28PO9vkz1NQS9jN9ZOOAHaHa?w=161&h=180"
            class="img-fluid mt-3" alt="Book Cover">
          <div class="card-body">
            <h5 class="fw-bold text-primary">{{ book.title }}</h5>
            <p><strong>Author:</strong> {{ book.author }}</p>
            <p><strong>Genre:</strong> {{ book.genre }}</p>
            <p><strong>ISBN:</strong> {{ book.isbn }}</p>
            <p><strong>Year:</strong> {{ book.yearPublished }}</p>
            <p><strong>Available:</strong> {{ book.availableCopies }}</p>
          </div>

          <div class="card-footer d-flex flex-wrap justify-content-center gap-2 p-3">
            <!-- MEMBER BUTTONS -->
            <ng-container *ngIf="userRole === 'member'">
              <button class="btn btn-outline-success" (click)="borrowBook(book.bookId)">
                <i class="bi bi-book"></i> Borrow
              </button>
              <button class="btn btn-outline-danger" (click)="returnBook(book.bookId)">
                <i class="bi bi-arrow-return-left"></i> Return
              </button>
            </ng-container>

            <!-- ADMIN BUTTONS -->
            <ng-container *ngIf="userRole === 'admin'">
              <button class="btn btn-outline-warning" (click)="updateBook(book.bookId)">
                <i class="bi bi-pencil-square"></i> Update
              </button>
              <button class="btn btn-outline-danger" (click)="deleteBook(book.bookId)">
                <i class="bi bi-trash"></i> Delete
              </button>
            </ng-container>
          </div>
        </div>
      </div>
    </ng-container>

    <!-- ‚ûï Add New Book Button (Only for ADMIN) -->
    <div *ngIf="userRole === 'admin'" class="col-sm-6 col-md-4 col-lg-3 mb-4 d-flex">
      <div class="card shadow w-100 text-center" style="cursor: pointer;" routerLink="/addBook">
        <div class="card-body d-flex flex-column justify-content-center align-items-center text-secondary">
          <i class="bi bi-plus-circle-fill display-4 mb-2"></i>
          <h5 class="fw-bold">Add New Book</h5>
        </div>
      </div>
    </div>
  </div>
</div>

import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router, RouterLink } from '@angular/router';
import { NavbarComponent } from '../navbar/navbar.component';
import { AllBook, BookService } from '../book.service';
import { FormsModule } from '@angular/forms';
import { jwtDecode } from 'jwt-decode';

@Component({
  selector: 'app-all-book',
  standalone: true,
  imports: [CommonModule, RouterLink, NavbarComponent, FormsModule],
  templateUrl: './all-book.component.html',
  styleUrls: ['./all-book.component.css']
})
export class AllBookComponent {
  books: AllBook[] = [];
  allBooks: AllBook[] = [];
  searchType: string = 'title';
  searchValue: string = '';
  error: any;
  userRole: string = ''; // "admin" or "member"

  constructor(private bookService: BookService, private route: Router) {
    this.extractRole();
    this.loadBooks();
  }

  extractRole(): void {
    const token = localStorage.getItem('JWT');
    if (token) {
      try {
        const decoded: any = jwtDecode(token);
        this.userRole = decoded.role || decoded.roles || '';
        localStorage.setItem("memberId", decoded.userId); // Store memberId
      } catch (err) {
        console.error('Failed to decode JWT', err);
      }
    }
  }

  loadBooks(): void {
    this.bookService.view().subscribe({
      next: (response: AllBook[]) => {
        this.books = response;
        this.allBooks = response;
      },
      error: err => {
        console.error(err);
        this.error = err.message;
      }
    });
  }

  searchBooks(): void {
    if (!this.searchValue.trim()) {
      this.books = this.allBooks;
      return;
    }

    switch (this.searchType) {
      case 'title':
        this.bookService.searchByTitle(this.searchValue).subscribe(data => this.books = data);
        break;
      case 'author':
        this.bookService.searchByAuthor(this.searchValue).subscribe(data => this.books = data);
        break;
      case 'genre':
        this.bookService.searchByGenre(this.searchValue).subscribe(data => this.books = data);
        break;
    }
  }

  deleteBook(bookId: string): void {
    if (confirm('Are you sure you want to delete this book?')) {
      this.bookService.delete(bookId).subscribe(() => {
        this.books = this.books.filter(book => book.bookId !== bookId);
        alert("Book deleted successfully");
      });
    }
  }

  updateBook(bookId: string): void {
    this.route.navigate(['/updatebook', bookId]);
  }

  trackById(index: number, book: AllBook) {
    return book.bookId;
  }

  borrowBook(bookId: string): void {
    this.bookService.borrowBook(bookId).subscribe({
      next: (res) => {
        alert('‚úÖ Book borrowed successfully!');
        console.log(res);
        this.loadBooks();
      },
      error: (err) => {
        console.error(err);
        alert('‚ùå Error borrowing book: ' + err.error);
      }
    });
  }

  returnBook(bookId: string): void {
    this.bookService.returnBook(bookId).subscribe({
      next: (res) => {
        alert('üìö Book returned successfully!');
        console.log(res);
        this.loadBooks();
      },
      error: (err) => {
        console.error(err);
        alert('‚ùå Error returning book: ' + err.error);
      }
    });
  }
}


import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, switchMap, throwError } from 'rxjs';

export interface AllBook {
  bookId: string;
  title: string;
  author: string;
  genre: string;
  isbn: string;
  yearPublished: number;
  availableCopies: number;
}

@Injectable({
  providedIn: 'root'
})
export class BookService {
  private bookUrl = 'http://localhost:9090/books';
  private memberUrl = 'http://localhost:9090/members';
  private borrowingUrl = 'http://localhost:9090/borrowing';

  constructor(private http: HttpClient) {}

  private getAuthHeaders(): HttpHeaders {
    const token = localStorage.getItem('JWT');
    return new HttpHeaders({
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`
    });
  }

  // üì• Get Member ID from email
  private getMemberIdFromEmail(): Observable<string> {
    const email = localStorage.getItem('email');
    if (!email) return throwError(() => new Error('Email not found in localStorage'));

    return this.http.get<any>(`${this.memberUrl}/email/${email}`, {
      headers: this.getAuthHeaders()
    }).pipe(
      switchMap((member) => {
        if (!member || !member.memberId) {
          return throwError(() => new Error('Member ID not found for email'));
        }
        return new Observable<string>((observer) => {
          observer.next(member.memberId);
          observer.complete();
        });
      })
    );
  }

  // üìö View All Books
  view(): Observable<AllBook[]> {
    return this.http.get<AllBook[]>(`${this.bookUrl}/getAllBook`, {
      headers: this.getAuthHeaders()
    });
  }

  // üîç Search
  searchByTitle(title: string): Observable<AllBook[]> {
    return this.http.get<AllBook[]>(`${this.bookUrl}/search/title/${title}`, {
      headers: this.getAuthHeaders()
    });
  }

  searchByAuthor(author: string): Observable<AllBook[]> {
    return this.http.get<AllBook[]>(`${this.bookUrl}/search/author/${author}`, {
      headers: this.getAuthHeaders()
    });
  }

  searchByGenre(genre: string): Observable<AllBook[]> {
    return this.http.get<AllBook[]>(`${this.bookUrl}/search/genre/${genre}`, {
      headers: this.getAuthHeaders()
    });
  }

  // ‚ûï Add
  add(book: AllBook): Observable<AllBook> {
    return this.http.post<AllBook>(`${this.bookUrl}/addBook`, book, {
      headers: this.getAuthHeaders()
    });
  }

  // üîÑ Update
  updateBook(bookId: string, book: AllBook): Observable<AllBook> {
    return this.http.put<AllBook>(`${this.bookUrl}/updateBook/${bookId}`, book, {
      headers: this.getAuthHeaders()
    });
  }

  // ‚ùå Delete
  delete(bookId: string): Observable<void> {
    return this.http.delete<void>(`${this.bookUrl}/deleteBook/${bookId}`, {
      headers: this.getAuthHeaders()
    });
  }

  // üìñ Get Book by ID
  getBookById(bookId: string): Observable<AllBook> {
    return this.http.get<AllBook>(`${this.bookUrl}/getBook/${bookId}`, {
      headers: this.getAuthHeaders()
    });
  }

  // ‚úÖ Borrow Book (calls /borrowing/borrow)
  borrowBook(bookId: string): Observable<any> {
    return this.getMemberIdFromEmail().pipe(
      switchMap((memberId) => {
        const request = {
          memberId: memberId,
          bookId: bookId
        };
        return this.http.post<any>(
          `${this.borrowingUrl}/borrow`,
          request,
          { headers: this.getAuthHeaders() }
        );
      })
    );
  }

  // üîÅ Return Book (calls /borrowing/return)
  returnBook(bookId: string): Observable<any> {
    return this.getMemberIdFromEmail().pipe(
      switchMap((memberId) => {
        const request = {
          memberId: memberId,
          bookId: bookId
        };
        return this.http.post<any>(
          `${this.borrowingUrl}/return`,
          request,
          { headers: this.getAuthHeaders() }
        );
      })
    );
  }
}
