import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class BorrowService {

  private pathBorrow = 'http://localhost:9090/borrowings/borrow'; // ("memberId": 3, "bookId": 2, "returnDate":"2025-06-03")
  private pathReturn = 'http://localhost:9090/borrowings/return'; // ("memberId": 1, "bookId": 2)
  private pathAllBorrows = 'http://localhost:9090/borrowings/'; // http://localhost:9090/borrowings/1 pass the member. Id

  constructor(private clients: HttpClient) { }

  borrowBook(memberId: number, bookId: number, returnDate: string): Observable<any> {
    const payload = { memberId, bookId, returnDate };
    return this.clients.post(this.pathBorrow, payload);
  }

  returnBook(memberId: number, bookId: number): Observable<any> {
    const payload = { memberId, bookId };
    return this.clients.post(this.pathReturn, payload);
  }

  viewBorrowsByMember(memberId: number): Observable<any> {
    return this.clients.get(this.pathAllBorrows + memberId);
  }

}

<app-navbar></app-navbar>

<div class="container " style="margin-top: 150px;">
    <div class="card p-4 shadow-sm">
      <h3 class="mb-3">Borrow Book</h3>
      <form (ngSubmit)="borrow()">
        <div class="mb-3">
          <label for="memberId" class="form-label">Member ID</label>
          <input type="number" id="memberId" class="form-control" [(ngModel)]="memberId" name="memberId" required min="1"/>
        </div>
   
        <div class="mb-3">
          <label for="bookId" class="form-label">Book ID</label>
          <input type="number" id="bookId" class="form-control" [(ngModel)]="bookId" name="bookId" required min="1"/>
        </div>
   
        <div class="mb-3">
          <label for="returnDate" class="form-label">Return Date</label>
          <input type="date" id="returnDate" class="form-control"  [(ngModel)]="returnDate" name="returnDate" required  min="{{ today }}" />
        </div>
   
        <button type="submit" class="btn btn-primary">Borrow</button>
      </form>
      <p class="mt-3 text-success" *ngIf="message">{{ message }}</p>
    </div>
  </div>

import { Component } from '@angular/core';
import { NavbarComponent } from '../navbar/navbar.component';
import { Router, RouterLink } from '@angular/router';
import { BorrowService } from '../borrow.service';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-borrow-book',
  imports: [NavbarComponent,RouterLink, FormsModule],
  templateUrl: './borrow-book.component.html',
  styleUrl: './borrow-book.component.css'
})
export class BorrowBookComponent {
  memberId!: number;
  bookId!: number;
  returnDate!: string;
  message: string = '';
  today: string = new Date().toISOString().split('T')[0]; 
 
  constructor(private borrowService: BorrowService, private router:Router) {}
 
  borrow() {
    if (!this.memberId || !this.bookId || !this.returnDate) {
      alert('Please fill all fields.');
      return;
    }
 
    this.borrowService.borrowBook(this.memberId, this.bookId, this.returnDate)
      .subscribe({
        next: (response) => {
          this.message = 'Book borrowed successfully!';
          console.log(response);
          alert(this.message);
          this.clearForm();
        },
        error: (err) => {
          this.message = 'Failed to borrow book. Please try again.';
          console.error(err);
          alert(this.message);
        }
      });
  }
 
  clearForm() {
    this.memberId = 0;
    this.bookId = 0;
    this.returnDate = '';
    this.router.navigate(['/borrow'])
  }
}

package com.cts.controller;

import java.util.List;

import org.springframework.web.bind.annotation.*;

import com.cts.dto.BorrowingTransactionDTO;
import com.cts.model.BorrowingTransaction;
import com.cts.service.BorrowingService;

import lombok.AllArgsConstructor;

@RestController
@AllArgsConstructor
@RequestMapping("/borrowings")
public class BorrowingController {

	private final BorrowingService borrowingService;

	@PostMapping("/borrow")
	public BorrowingTransaction borrowBook(@RequestBody BorrowingTransactionDTO transactionDTO) {
		return borrowingService.borrowBook(transactionDTO);
	}

	@PostMapping("/return")
	public BorrowingTransaction returnBook(@RequestBody BorrowingTransactionDTO transactionDTO) {
		return borrowingService.returnBook(transactionDTO.getMemberId(), transactionDTO.getBookId());
	}

	@GetMapping("/member/{memberId}") 
	public List<BorrowingTransaction> getBorrowedBooks(@PathVariable Long memberId) {
		return borrowingService.getMemberBorrowedBooks(memberId);
	}

	@GetMapping("/getall")
	public List<BorrowingTransaction> getAllBorrows() {
		return borrowingService.getAllBorrows();
	}
}


package com.cts.service;

import java.time.LocalDate;
import java.util.List;

import org.springframework.stereotype.Service;

import com.cts.dto.BorrowingTransactionDTO;
import com.cts.dto.MemberDTO;
import com.cts.dto.BookDTO;
import com.cts.exception.BorrowingNotAllowedException;
import com.cts.exception.BorrowingTransactionNotFoundException;
import com.cts.feign.BookClient;
import com.cts.feign.MailClient;
import com.cts.feign.MemberClient;
import com.cts.model.BorrowingTransaction;
import com.cts.repository.BorrowingRepository;

import jakarta.transaction.Transactional;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@AllArgsConstructor
public class BorrowingServiceImpl implements BorrowingService {

	private final BorrowingRepository repository;
	private final BookClient bookClient;
	private final MemberClient memberClient;
	private final MailClient mailClient;

	@Override
	public BorrowingTransaction borrowBook(BorrowingTransactionDTO transactionDTO) {
		log.info("Attempting to borrow book with ID: {} for member ID: {}", transactionDTO.getBookId(),
				transactionDTO.getMemberId());

		// Validate member
		MemberDTO member = memberClient.getMember(transactionDTO.getMemberId());
		if (member == null) {
			throw new BorrowingNotAllowedException("Member not found");
		}

		// Validate book
		BookDTO book = bookClient.getBookById(transactionDTO.getBookId());
		if (book == null || book.getAvailableCopies() <= 0) {
			throw new BorrowingNotAllowedException("Book unavailable");
		}

		// Rules
		long activeCount = repository
				.findByMemberIdAndStatus(transactionDTO.getMemberId(), BorrowingTransaction.Status.BORROWED).size();

		if (activeCount >= 5) {
			throw new BorrowingNotAllowedException("Borrowing limit exceeded (Max 5 books)");
		}

		boolean alreadyBorrowed = repository.findByBookIdAndMemberIdAndStatus(transactionDTO.getBookId(),
				transactionDTO.getMemberId(), BorrowingTransaction.Status.BORROWED).isPresent();

		if (alreadyBorrowed) {
			throw new BorrowingNotAllowedException("Book already borrowed by this member");
		}

		// Create and Save transaction
		BorrowingTransaction tx = BorrowingTransaction.builder().bookId(transactionDTO.getBookId())
				.memberId(transactionDTO.getMemberId()).borrowDate(LocalDate.now())
				.dueDate(LocalDate.now().plusDays(14)).status(BorrowingTransaction.Status.BORROWED).fineAmount(0)
				.bookTitle(book.getTitle()).build();

		log.info("Transaction ready to save: {}", tx);
		BorrowingTransaction savedTx = repository.save(tx);

		bookClient.updateBookCopies(transactionDTO.getBookId(), book.getAvailableCopies() - 1);

		// Try sending email (don't fail the method if email fails)
		try {
			String msg = "Book borrowed: " + book.getTitle() + ". Return by: " + savedTx.getDueDate();
			mailClient.sendEmail(member.getEmail(), "Library Borrowing Info", msg);
			log.info("Email sent to {}", member.getEmail());
		} catch (Exception e) {
			log.error("Email failed: {}", e.getMessage());
		}

		return savedTx;
	}

	@Override
	public BorrowingTransaction returnBook(Long memberId, Long bookId) {
		log.info("Returning book with ID: {} for member ID: {}", bookId, memberId);

		// Get active borrowing
		BorrowingTransaction tx = repository
				.findByBookIdAndMemberIdAndStatus(bookId, memberId, BorrowingTransaction.Status.BORROWED)
				.orElseThrow(() -> new BorrowingTransactionNotFoundException("No active borrowing found"));

		LocalDate today = LocalDate.now();
		LocalDate due = tx.getDueDate();
		double fine = today.isAfter(due) ? 7.0 * java.time.temporal.ChronoUnit.DAYS.between(due, today) : 0;

		// Update transaction
		tx.setReturnDate(today);
		tx.setFineAmount(fine);
		tx.setStatus(BorrowingTransaction.Status.RETURNED);

		// Fetch book details
		BookDTO book = bookClient.getBookById(bookId);
		if (book == null) {
			throw new RuntimeException("Book not found during return");
		}

		tx.setBookTitle(book.getTitle());
		BorrowingTransaction savedTx = repository.save(tx);

		// Update book copies
		bookClient.updateBookCopies(bookId, book.getAvailableCopies() + 1);

		// Get member info
		MemberDTO member = memberClient.getMember(memberId);

		// Send email (safely)
		try {
			String msg = "Book returned: " + book.getTitle() + ". Fine applied: ₹" + fine;
			mailClient.sendEmail(member.getEmail(), "Library Return Info", msg);
			log.info("Return email sent to {}", member.getEmail());
		} catch (Exception e) {
			log.error("Failed to send return email: {}", e.getMessage());
		}

		log.info("Return complete. Fine: ₹{}", fine);
		return tx; // return the updated tx (with bookTitle)
	}

	@Override
	public List<BorrowingTransaction> getMemberBorrowedBooks(Long memberId) {
		List<BorrowingTransaction> transactions = repository.findByMemberIdAndStatus(memberId,
				BorrowingTransaction.Status.BORROWED);

		// Populate book titles manually
		transactions.forEach(tx -> {
			try {
				BookDTO book = bookClient.getBookById(tx.getBookId());
				tx.setBookTitle(book.getTitle()); // Set the transient field manually
			} catch (Exception e) {
				log.warn("Failed to fetch book title for Book ID: {}", tx.getBookId());
				tx.setBookTitle("Unavailable");
			}
		});

		return transactions;
	}

	@Override
	public List<BorrowingTransaction> getAllBorrows() {
		List<BorrowingTransaction> transactions = repository.findAll();

		// Populate book titles manually
		transactions.forEach(tx -> {
			try {
				BookDTO book = bookClient.getBookById(tx.getBookId());
				tx.setBookTitle(book.getTitle());
			} catch (Exception e) {
				log.warn("Failed to fetch book title for Book ID: {}", tx.getBookId());
				tx.setBookTitle("Unavailable");
			}
		});

		return transactions;
	}
}

i want to make a good front-end angular please make it according to the codes provided ,

