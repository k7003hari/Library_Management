package com.cts.service;

import java.time.LocalDate;
import java.util.List;

import org.springframework.stereotype.Service;

import com.cts.dto.BookDTO;
import com.cts.dto.BorrowingTransactionDTO;
import com.cts.dto.MemberDTO;
import com.cts.exception.BorrowingNotAllowedException;
import com.cts.exception.BorrowingTransactionNotFoundException;
import com.cts.feign.BookClient;
import com.cts.feign.MailClient;
import com.cts.feign.MemberClient;
import com.cts.model.BorrowingTransaction;
import com.cts.repository.BorrowingRepository;

import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@AllArgsConstructor
public class BorrowingServiceImpl implements BorrowingService {

	private final BorrowingRepository repository;
	private final BookClient bookClient;
	private final MemberClient memberClient;
	private final MailClient mailClient;

	@Override
	public BorrowingTransaction borrowBook(BorrowingTransactionDTO transactionDTO) {
		log.info("Attempting to borrow book with ID: {} for member ID: {}", transactionDTO.getBookId(),
				transactionDTO.getMemberId());

		// Validate member
		MemberDTO member = memberClient.getMember(transactionDTO.getMemberId());
		if (member == null) {
			throw new BorrowingNotAllowedException("Member not found");
		}

		// Validate book
		BookDTO book = bookClient.getBookById(transactionDTO.getBookId());
		if (book == null || book.getAvailableCopies() <= 0) {
			throw new BorrowingNotAllowedException("Book unavailable");
		}

		// Rules
		long activeCount = repository
				.findByMemberIdAndStatus(transactionDTO.getMemberId(), BorrowingTransaction.Status.BORROWED).size();

		if (activeCount >= 5) {
			throw new BorrowingNotAllowedException("Borrowing limit exceeded (Max 5 books)");
		}

		boolean alreadyBorrowed = repository.findByBookIdAndMemberIdAndStatus(transactionDTO.getBookId(),
				transactionDTO.getMemberId(), BorrowingTransaction.Status.BORROWED).isPresent();

		if (alreadyBorrowed) {
			throw new BorrowingNotAllowedException("Book already borrowed by this member");
		}

		// Create and Save transaction    //LocalDate.now()
		BorrowingTransaction tx = BorrowingTransaction.builder().bookId(transactionDTO.getBookId())
				.memberId(transactionDTO.getMemberId()).borrowDate(LocalDate.now())
				.dueDate(LocalDate.now().plusDays(14)).status(BorrowingTransaction.Status.BORROWED).fineAmount(0)
				.bookTitle(book.getTitle()).build();

		log.info("Transaction ready to save: {}", tx);
		BorrowingTransaction savedTx = repository.save(tx);

		bookClient.updateBookCopies(transactionDTO.getBookId(), book.getAvailableCopies() - 1);

		try {
			String msg = "Book borrowed: " + book.getTitle() + ". Return by: " + savedTx.getDueDate();
			mailClient.sendEmail(member.getEmail(), "Library Borrowing Info", msg);
			log.info("Email sent to {}", member.getEmail());
		} catch (Exception e) {
			log.error("Email failed: {}", e.getMessage());
		}

		return savedTx;
	}

	@Override
	public BorrowingTransaction returnBook(Long memberId, Long bookId) {
		log.info("Returning book with ID: {} for member ID: {}", bookId, memberId);

		// Get active borrowing
		BorrowingTransaction tx = repository
				.findByBookIdAndMemberIdAndStatus(bookId, memberId, BorrowingTransaction.Status.BORROWED)
				.orElseThrow(() -> new BorrowingTransactionNotFoundException("No active borrowing found"));

		LocalDate today = LocalDate.now();
		LocalDate due = tx.getDueDate();
		double fine = today.isAfter(due) ? 7.0 * java.time.temporal.ChronoUnit.DAYS.between(due, today) : 0;

		// Update transaction
		tx.setReturnDate(today);
		tx.setFineAmount(fine);
		tx.setStatus(BorrowingTransaction.Status.RETURNED);

		// Fetch book details
		BookDTO book = bookClient.getBookById(bookId);
		if (book == null) {
			throw new RuntimeException("Book not found during return");
		}

		tx.setBookTitle(book.getTitle());
		BorrowingTransaction savedTx = repository.save(tx);

		// Update book copies
		bookClient.updateBookCopies(bookId, book.getAvailableCopies() + 1);

		// Get member info
		MemberDTO member = memberClient.getMember(memberId);

		// Send email (safely)
		try {
			String msg = "Book returned: " + book.getTitle() + ". Fine applied: ₹" + fine;
			mailClient.sendEmail(member.getEmail(), "Library Return Info", msg);
			log.info("Return email sent to {}", member.getEmail());
		} catch (Exception e) {
			log.error("Failed to send return email: {}", e.getMessage());
		}

		log.info("Return complete. Fine: ₹{}", fine);
		return tx; // return the updated tx (with bookTitle)
	}

	@Override
	public List<BorrowingTransactionDTO> getMemberBorrowedBooks(Long memberId) {
		List<BorrowingTransaction> transactions = repository.findByMemberIdAndStatus(memberId,
				BorrowingTransaction.Status.BORROWED);
	 
		transactions.forEach(tx -> {
			try {
				BookDTO book = bookClient.getBookById(tx.getBookId());
				tx.setBookTitle(book.getTitle());
			} catch (Exception e) {
				log.warn("Failed to fetch book title for Book ID: {}", tx.getBookId());
				tx.setBookTitle("Unavailable");
			}
		});
	 
		return transactions.stream().map(this::mapToDTO).toList();
	}
	 
	@Override
	public List<BorrowingTransactionDTO> getAllBorrows() {
		List<BorrowingTransaction> transactions = repository.findAll();
	 
		transactions.forEach(tx -> {
			try {
				BookDTO book = bookClient.getBookById(tx.getBookId());
				tx.setBookTitle(book.getTitle());
			} catch (Exception e) {
				log.warn("Failed to fetch book title for Book ID: {}", tx.getBookId());
				tx.setBookTitle("Unavailable");
			}
		});
	 
		return transactions.stream().map(this::mapToDTO).toList();
	}
	 
	private BorrowingTransactionDTO mapToDTO(BorrowingTransaction tx) {
		return BorrowingTransactionDTO.builder()
				.transactionId(tx.getTransactionId())
				.bookId(tx.getBookId())
				.memberId(tx.getMemberId())
				.borrowDate(tx.getBorrowDate())
				.dueDate(tx.getDueDate())
				.returnDate(tx.getReturnDate())
				.status(BorrowingTransactionDTO.Status.valueOf(tx.getStatus().name()))
				.fineAmount(tx.getFineAmount())
				.bookTitle(tx.getBookTitle())
				.build();
	}
}

package com.cts.controller;

import java.util.List;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.cts.dto.BorrowingTransactionDTO;
import com.cts.model.BorrowingTransaction;
import com.cts.service.BorrowingService;

import lombok.AllArgsConstructor;

@RestController
@AllArgsConstructor
@RequestMapping("/borrowings")
public class BorrowingController {

	private final BorrowingService borrowingService;

	@PostMapping("/borrow")
	public BorrowingTransaction borrowBook(@RequestBody BorrowingTransactionDTO transactionDTO) {
		return borrowingService.borrowBook(transactionDTO);
	}

	@PostMapping("/return")
	public BorrowingTransaction returnBook(@RequestBody BorrowingTransactionDTO transactionDTO) {
		return borrowingService.returnBook(transactionDTO.getMemberId(), transactionDTO.getBookId());
	}

	@GetMapping("/member/{memberId}")
	public List<BorrowingTransactionDTO> getMemberBorrowedBooks(@PathVariable Long memberId) {
	return borrowingService.getMemberBorrowedBooks(memberId);
	}
	 
	@GetMapping("/getall")
	public List<BorrowingTransactionDTO> getAllBorrows() {
	return borrowingService.getAllBorrows();
	}
}

package com.cts.dto;
 
import java.time.LocalDate;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
 
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BorrowingTransactionDTO {
    private Long transactionId;
    private Long bookId;
    private Long memberId;
    private LocalDate borrowDate;
    private LocalDate dueDate;
    private LocalDate returnDate;
    private Status status; // Enum: BORROWED or RETURNED
    private double fineAmount;
    private String bookTitle;
 
    public enum Status {
        BORROWED,
        RETURNED
    }
}
 
package com.cts.model;
 
import java.time.LocalDate;
 
import jakarta.persistence.*;
import lombok.*;
 
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BorrowingTransaction {
 
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long transactionId;
 
    private Long bookId;
    private Long memberId;
 
    private LocalDate borrowDate;
    private LocalDate dueDate;
    private LocalDate returnDate;
 
    @Enumerated(EnumType.STRING)
    private Status status;
 
    private double fineAmount;
 
    @Transient
    private String bookTitle;
 
    public enum Status {
        BORROWED,
        RETURNED
    }
}

package com.cts.repository;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;

import com.cts.model.BorrowingTransaction;

public interface BorrowingRepository extends JpaRepository<BorrowingTransaction, Long> {
	List<BorrowingTransaction> findByMemberIdAndStatus(Long memberId, BorrowingTransaction.Status status);

	Optional<BorrowingTransaction> findByBookIdAndMemberIdAndStatus(Long bookId, Long memberId,
			BorrowingTransaction.Status status);
}

Borrow module codes 

package com.cts.dto;

import java.time.LocalDate;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BorrowingTransactionDTO {
	private Long transactionId;
	private Long bookId;
	private Long memberId;
	private LocalDate borrowDate;
	private LocalDate dueDate;
	private LocalDate returnDate;
	private Status status; // Enum: BORROWED or RETURNED
	private double fineAmount;
	private String bookTitle;

	public enum Status {
		BORROWED, RETURNED
	}
}
package com.cts.dto;

import java.math.BigDecimal;
import java.time.LocalDate;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FineDTO {
	private Long fineId;
	private Object memberId; 
	private BigDecimal amount;
	private String status;
	private LocalDate transactionDate;
	private String message; 

}
package com.cts.feign;

import java.util.List;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import com.cts.dto.BorrowingTransactionDTO;

@FeignClient(name = "BORROWINGSERVICE", path = "/borrowings")
public interface BorrowingClient {

	@GetMapping("/member/{memberId}")
	public List<BorrowingTransactionDTO> getMemberBorrowedBooks(@PathVariable Long memberId);
}
package com.cts.repository;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;

import com.cts.model.Fine;
import com.cts.model.Fine.FineStatus;

public interface FineRepository extends JpaRepository<Fine, Long> {
	List<Fine> findByMemberId(Long memberId);

	List<Fine> findByMemberIdAndStatus(Long memberId, Fine.FineStatus status);
}

package com.cts.service;

import java.util.List;

import com.cts.dto.FineDTO;

public interface FineService {
	FineDTO generateFineFromBorrowService(Long memberId);

	FineDTO payFine(Long memberId, Long fineId);

	List<FineDTO> getAllFines();

	List<FineDTO> getFinesByMemberId(Long memberId);
}

package com.cts.service;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;

import com.ctc.exception.FineNotFoundException;
import com.ctc.exception.UnauthorizedAccessException;
import com.cts.dto.BorrowingTransactionDTO;
import com.cts.dto.FineDTO;
import com.cts.dto.MemberDTO;
import com.cts.feign.BorrowingClient;
import com.cts.feign.MemberClient;
import com.cts.model.Fine;
import com.cts.model.Fine.FineStatus;
import com.cts.repository.FineRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class FineServiceImpl implements FineService {

	private final FineRepository fineRepository;
	private final BorrowingClient borrowingClient;
	private final MemberClient memberClient;

	@Override
	public FineDTO generateFineFromBorrowService(Long memberId) {
		log.info("Fetching fine data from BorrowingService for member: {}", memberId);

		List<Fine> existing = fineRepository.findByMemberIdAndStatus(memberId, FineStatus.PENDING);
		if (!existing.isEmpty()) {
			throw new RuntimeException("⚠️ You already have a pending fine.");
		}

		List<BorrowingTransactionDTO> overdueTxs = borrowingClient.getMemberBorrowedBooks(memberId);

		BigDecimal totalFine = overdueTxs.stream().map(tx -> BigDecimal.valueOf(tx.getFineAmount()))
				.reduce(BigDecimal.ZERO, BigDecimal::add);

		if (totalFine.compareTo(BigDecimal.ZERO) <= 0) {
			return FineDTO.builder().fineId(null).memberId(memberId).amount(BigDecimal.ZERO).status("NO_FINE")
					.transactionDate(null).message("✅ No fines due. All books were returned on time.").build();
		}

		Fine fine = Fine.builder().memberId(memberId).amount(totalFine).status(FineStatus.PENDING)
				.transactionDate(LocalDate.now()).build();

		fineRepository.save(fine);

		return mapToDTO(fine);
	}

	@Override
	public FineDTO payFine(Long memberId, Long fineId) {
		Fine fine = fineRepository.findById(fineId)
				.orElseThrow(() -> new FineNotFoundException("❌ Fine not found: ID " + fineId));

		if (!fine.getMemberId().equals(memberId)) {
			throw new UnauthorizedAccessException("🚫 You are not authorized to pay this fine.");
		}

		if (fine.getStatus() == FineStatus.PAID) {
			throw new RuntimeException("ℹ️ Fine already paid.");
		}

		fine.setStatus(FineStatus.PAID);
		fineRepository.save(fine);

		return mapToDTO(fine);
	}

	@Override
	public List<FineDTO> getAllFines() {
		return fineRepository.findAll().stream().map(this::mapToDTO).collect(Collectors.toList());
	}

	@Override
	public List<FineDTO> getFinesByMemberId(Long memberId) {
		return fineRepository.findByMemberId(memberId).stream().map(this::mapToDTO).collect(Collectors.toList());
	}

	private FineDTO mapToDTO(Fine fine) {
		MemberDTO member = memberClient.getMemberById(fine.getMemberId());

		return FineDTO.builder().fineId(fine.getFineId()).memberId(member).amount(fine.getAmount())
				.status(fine.getStatus().name()).transactionDate(fine.getTransactionDate())
				.message("✅ Fine details fetched.").build();
	}
}

package com.cts.controller;

import java.util.List;

import org.springframework.web.bind.annotation.*;

import com.cts.dto.FineDTO;
import com.cts.service.FineService;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/fines")
@RequiredArgsConstructor
public class FineController {

	private final FineService fineService;

	@PostMapping("/generate/{memberId}")
	public FineDTO generateFine(@PathVariable Long memberId) {
		return fineService.generateFineFromBorrowService(memberId);
	}

	@PostMapping("/pay/{memberId}/{fineId}")
	public FineDTO payFine(@PathVariable Long memberId, @PathVariable Long fineId) {
		return fineService.payFine(memberId, fineId);
	}

// ✅ 3. Get all fines (admin)
	@GetMapping("/allfines")
	public List<FineDTO> getAllFines() {
		return fineService.getAllFines();
	}

// ✅ 4. Get own fines
	@GetMapping("/member/{memberId}")
	public List<FineDTO> getFinesForMember(@PathVariable Long memberId) {
		return fineService.getFinesByMemberId(memberId);
	}
}

