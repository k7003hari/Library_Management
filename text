package com.cts.controller;

import java.util.List;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.cts.dto.FineDTO;
import com.cts.service.FineService;

import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/fines")
@AllArgsConstructor
public class FineController {
 
    private final FineService fineService;
 
    // Endpoint to calculate fine for a member
    @PostMapping("/calculatefine/{memberId}")
    public FineDTO calculateFine(@PathVariable Long memberId) {
        return fineService.calculateFine(memberId);
    }
 
    // Endpoint for member to pay their fine
    @PostMapping("/pay/{memberId}/{fineId}")
    public void payFine(@PathVariable Long memberId, @PathVariable Long fineId) {
        fineService.payFine(memberId, fineId);
    }
 
    // Endpoint for Admin to view all fines
    @GetMapping("/allfines")
    public List<FineDTO> getAllFines() {
        return fineService.getAllFines();
    }
}
package com.cts.service;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;

import com.ctc.exception.FineNotFoundException;
import com.ctc.exception.NoFineDueException;
import com.ctc.exception.UnauthorizedAccessException;
import com.cts.dto.BorrowingTransactionDTO;
import com.cts.dto.FineDTO;
import com.cts.feign.BorrowingClient;
import com.cts.feign.MemberClient;
import com.cts.model.Fine;
import com.cts.repository.FineRepository;

import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@AllArgsConstructor
@Slf4j
public class FineServiceImpl implements FineService {

    private final FineRepository fineRepository;
    private final BorrowingClient borrowingClient;
    private final MemberClient memberClient;

    @Override
    public FineDTO calculateFine(Long memberId) {
    log.info("Calculating fine for member ID: {}", memberId);
        List<BorrowingTransactionDTO> borrowedBooks = borrowingClient.getBorrowedBooksByMember(memberId);
     
        BigDecimal totalFine = BigDecimal.ZERO;
     
        for (BorrowingTransactionDTO transaction : borrowedBooks) {
            long overdueDays = calculateOverdueDays(transaction.getReturnDate());
            if (overdueDays > 0) {
                totalFine = totalFine.add(BigDecimal.valueOf(overdueDays).multiply(new BigDecimal("1.00")));
            }
        }
     
        if (totalFine.compareTo(BigDecimal.ZERO) <= 0) {
    log.info("No fine applicable for member ID: {}", memberId);
            throw new NoFineDueException("No fine due at this time.");
        }
     
        // Save fine
        Fine fine = Fine.builder()
                .memberId(memberId)
                .amount(totalFine)
                .status(Fine.FineStatus.PENDING)
                .transactionDate(LocalDate.now())
                .build();
     
        fineRepository.save(fine);
    log.info("Fine of {} saved for member ID: {}", totalFine, memberId);
     
        return new FineDTO(
                fine.getFineId(),
                memberClient.getMemberById(memberId),
                fine.getAmount(),
                fine.getStatus().name(),
                fine.getTransactionDate()
        );
    }

    @Override
    public FineDTO payFine(Long memberId, Long fineId) {
        log.info("Paying fine with ID: {} for member ID: {}", fineId, memberId);
        Fine fine = fineRepository.findById(fineId)
                .orElseThrow(() -> new FineNotFoundException("Fine not found with ID: " + fineId));

        if (!fine.getMemberId().equals(memberId)) {
            log.error("Unauthorized access attempt by member ID: {}", memberId);
            throw new UnauthorizedAccessException("You are not authorized to pay this fine.");
        }

        fine.setStatus(Fine.FineStatus.PAID);
        fineRepository.save(fine);
        log.info("Fine paid for member ID: {}", memberId);
        return new FineDTO(
                fine.getFineId(),
                memberClient.getMemberById(memberId),
                fine.getAmount(),
                fine.getStatus().name(),
                fine.getTransactionDate());
    }


    @Override
    public List<FineDTO> getAllFines() {
        log.debug("Fetching all fines");
        List<Fine> fines = fineRepository.findAll();
        return fines.stream()
                .map(fine -> new FineDTO(fine.getFineId(), memberClient.getMemberById(fine.getMemberId()), fine.getAmount(), fine.getStatus().name(), fine.getTransactionDate()))
                .collect(Collectors.toList());
    }
    
    private long calculateOverdueDays(LocalDate returnDate) {
        if (returnDate == null || returnDate.isBefore(LocalDate.now())) {
            return returnDate == null ? 0 : returnDate.until(LocalDate.now()).getDays();
        }
        return 0;
    }
}

package com.cts.service;

import java.time.LocalDate;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import com.cts.dto.BorrowingTransactionDTO;
import com.cts.exception.BorrowingNotAllowedException;
import com.cts.exception.BorrowingTransactionNotFoundException;
import com.cts.feign.BookClient;
//import com.cts.feign.MailClient;
import com.cts.feign.MemberClient;
import com.cts.model.BorrowingTransaction;
import com.cts.repository.BorrowingRepository;

import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@AllArgsConstructor
public class BorrowingServiceImpl implements BorrowingService {

	private static final Logger logger = LoggerFactory.getLogger(BorrowingServiceImpl.class);

	private final BorrowingRepository repository;
	private final BookClient bookClient;
	private final MemberClient memberClient;
//	private final MailClient mailClient;

	@Override
	public BorrowingTransaction borrowBook(BorrowingTransactionDTO transactionDTO) {
	logger.info("Attempting to borrow book with ID: {} for member ID: {}", transactionDTO.getBookId(), transactionDTO.getMemberId());
	 
	    // Validate member and book
	    memberClient.getMember(transactionDTO.getMemberId()); // Ensure member exists
	    bookClient.getBook(transactionDTO.getBookId());       // Ensure book exists
	 
	    // Check for borrowing limit
	    long activeBorrowings = repository.findByMemberIdAndStatus(transactionDTO.getMemberId(), BorrowingTransaction.Status.BORROWED).size();
	    if (activeBorrowings >= 5) {
	        logger.warn("Borrowing limit exceeded for member ID: {}", transactionDTO.getMemberId());
	        throw new BorrowingNotAllowedException("Borrowing limit exceeded");
	    }
	 
	    // Check if the same book is already borrowed by the same member
	    boolean alreadyBorrowedSameBook = repository
	        .findByBookIdAndMemberIdAndStatus(transactionDTO.getBookId(), transactionDTO.getMemberId(), BorrowingTransaction.Status.BORROWED)
	        .isPresent();
	 
	    if (alreadyBorrowedSameBook) {
	        logger.warn("Member ID: {} is already borrowing Book ID: {}", transactionDTO.getMemberId(), transactionDTO.getBookId());
	        throw new BorrowingNotAllowedException("Book is already borrowed by this member");
	    }
	 
	    // Create new borrowing transaction
	    BorrowingTransaction tx = BorrowingTransaction.builder()
	            .bookId(transactionDTO.getBookId())
	            .memberId(transactionDTO.getMemberId())
	            .borrowDate(LocalDate.now())
	            .status(BorrowingTransaction.Status.BORROWED)
	            .build();
	 
	    repository.save(tx);
//	    log.info("New Borrowing is done");
//		String msg="Successfully borrowed  :"+transactionDTO.getBookId()+" Book by Member "+transactionDTO.getMemberId()+" ";
//		mailClient.sendEmail("k7003hari@gmail.com@gmail.com","Hotel Booking System",msg);
//	logger.info("Book borrowed successfully: Book ID={}, Member ID={}", transactionDTO.getBookId(), transactionDTO.getMemberId());
	    return tx;
	}
	
	@Override
	public List<BorrowingTransaction> getAllBorrows() {
	    log.debug("Fetching all Borrows");
	    return repository.findAll();
	}


	@Override
	public BorrowingTransaction returnBook(Long memberId, Long bookId) {
		logger.info("Attempting to return book with ID: {} for member ID: {}", bookId, memberId);

		BorrowingTransaction tx = repository
				.findByBookIdAndMemberIdAndStatus(bookId, memberId, BorrowingTransaction.Status.BORROWED)
				.orElseThrow(() -> {
					logger.error("No active borrowing found for book ID: {} and member ID: {}", bookId, memberId);
					return new BorrowingTransactionNotFoundException("No active borrowing found");
				});

		tx.setStatus(BorrowingTransaction.Status.RETURNED);
		tx.setReturnDate(LocalDate.now());
		repository.save(tx);

		logger.info("Book returned successfully: Book ID={}, Member ID={}", bookId, memberId);
		return tx;
	}

	@Override
	public List<BorrowingTransaction> getMemberBorrowedBooks(Long memberId) {
		logger.debug("Fetching borrowed books for member ID: {}", memberId);

		List<BorrowingTransaction> borrowedBooks = repository.findByMemberIdAndStatus(memberId,
				BorrowingTransaction.Status.BORROWED);

		logger.info("Retrieved {} borrowed books for member ID: {}", borrowedBooks.size(), memberId);
		return borrowedBooks;
	}

}
