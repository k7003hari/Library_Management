package com.cts.controller;

import java.util.List;

import org.springframework.web.bind.annotation.*;

import com.cts.dto.FineDTO;
import com.cts.service.FineService;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/fines")
@RequiredArgsConstructor
public class FineController {

	private final FineService fineService;

	// ‚úÖ 1. Calculate fine for a member (creates a new fine if overdue exists)
	@PostMapping("/calculatefine/{memberId}")
	public FineDTO calculateFine(@PathVariable Long memberId) {
		return fineService.calculateFine(memberId);
	}

	// ‚úÖ 2. Pay a specific fine for the logged-in member
	@PostMapping("/pay/{memberId}/{fineId}")
	public FineDTO payFine(@PathVariable Long memberId, @PathVariable Long fineId) {
		return fineService.payFine(memberId, fineId);
	}

	// ‚úÖ 3. Admin - get all fines
	@GetMapping("/allfines")
	public List<FineDTO> getAllFines() {
		return fineService.getAllFines();
	}

	// ‚úÖ 4. Member - get own fines
	@GetMapping("/member/{memberId}")
	public List<FineDTO> getFinesForMember(@PathVariable Long memberId) {
		return fineService.getFinesByMemberId(memberId);
	}
}

package com.cts.dto;

import java.time.LocalDate;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BorrowingTransactionDTO {
	private Long transactionId;
	private Long bookId;
	private Long memberId;
	private LocalDate borrowDate;
	private LocalDate dueDate;
	private LocalDate returnDate;
	private Status status; // Enum: BORROWED or RETURNED
	private double fineAmount;
	private String bookTitle;

	public enum Status {
		BORROWED, RETURNED
	}
}

package com.cts.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@AllArgsConstructor
public class ErrorResponse {
   private String code;
   private String message;
   private String path;
   private LocalDateTime timestamp = LocalDateTime.now();

   public ErrorResponse(String code, String message, String path) {
       this.code = code;
       this.message = message;
       this.path = path;
   }
}
package com.cts.dto;

import java.math.BigDecimal;
import java.time.LocalDate;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FineDTO {
	private Long fineId;
	private Object memberId; 
	private BigDecimal amount;
	private String status;
	private LocalDate transactionDate;
	private String message; 

}

package com.cts.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class MemberDTO {
	private Long memberId;
	private String name;
	private String email;
	private String phone;
	private String address;
	private String membershipStatus;
}

package com.cts.feign;

import java.util.List;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import com.cts.dto.BorrowingTransactionDTO;

@FeignClient(name = "BORROWINGSERVICE", path = "/borrowings")
public interface BorrowingClient {
 
	@GetMapping("/member/{memberId}")
	public List<BorrowingTransactionDTO> getBorrowedBooks(@PathVariable Long memberId);
}

package com.cts.feign;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

@FeignClient(name = "MAILNOTIFICATION", path = "/email")
public interface MailClient {
	@PostMapping("/send")
	public String sendEmail(@RequestParam String recipient, @RequestParam String subject,
			@RequestParam String message) ;
 
}

package com.cts.feign;

import java.util.List;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import com.cts.dto.MemberDTO;

@FeignClient(name = "MEMBERSERVICE", path = "/members")
public interface MemberClient {
 
    @GetMapping("/{memberId}")
    MemberDTO getMemberById(@PathVariable("memberId") Long memberId);
 
    @GetMapping("/email/{email}")
    MemberDTO getMemberByEmail(@PathVariable("email") String email);
 
    @GetMapping("/getallMember")
    List<MemberDTO> getAllMembers();
    
    // Remove getMember/{id}/{Email} if unused or add the corresponding controller method if needed.
}

package com.cts.model;

import java.math.BigDecimal;
import java.time.LocalDate;

import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Fine {


	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long fineId;

	private Long memberId;

	private BigDecimal amount;

	@Enumerated(EnumType.STRING)
	private FineStatus status;

	private LocalDate transactionDate;

	public enum FineStatus {
		PAID, PENDING
	}
}

package com.cts.repository;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;

import com.cts.model.Fine;
import com.cts.model.Fine.FineStatus;

public interface FineRepository extends JpaRepository<Fine, Long> {
	List<Fine> findByMemberId(Long memberId);

	List<Fine> findByMemberIdAndStatus(Long memberId, Fine.FineStatus status);
}

package com.cts.service;

import java.util.List;

import com.cts.dto.FineDTO;

public interface FineService {
 
    FineDTO calculateFine(Long memberId);
 
    FineDTO payFine(Long memberId, Long fineId);
 
    List<FineDTO> getAllFines();
 
    List<FineDTO> getFinesByMemberId(Long memberId);
}

package com.cts.service;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;

import com.ctc.exception.FineNotFoundException;
import com.ctc.exception.UnauthorizedAccessException;
import com.cts.dto.BorrowingTransactionDTO;
import com.cts.dto.FineDTO;
import com.cts.feign.BorrowingClient;
import com.cts.feign.MemberClient;
import com.cts.model.Fine;
import com.cts.repository.FineRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class FineServiceImpl implements FineService {

	private final FineRepository fineRepository;
	private final BorrowingClient borrowingClient;
	private final MemberClient memberClient;

	private static final BigDecimal FINE_PER_DAY = BigDecimal.valueOf(1.00);

	@Override
	public FineDTO calculateFine(Long memberId) {
		log.info("Calculating fine for member ID: {}", memberId);

		List<Fine> pendingFines = fineRepository.findByMemberIdAndStatus(memberId, Fine.FineStatus.PENDING);
		if (!pendingFines.isEmpty()) {
			throw new RuntimeException("‚ö†Ô∏è You already have a pending fine. Please pay it before calculating again.");
		}

		List<BorrowingTransactionDTO> borrowedBooks = borrowingClient.getBorrowedBooks(memberId);
		BigDecimal totalFine = BigDecimal.ZERO;

		for (BorrowingTransactionDTO tx : borrowedBooks) {
			if (tx.getStatus() == BorrowingTransactionDTO.Status.RETURNED) {
				LocalDate dueDate = tx.getBorrowDate().plusDays(14);
				long overdueDays = calculateOverdueDays(dueDate, tx.getReturnDate());

				if (overdueDays > 0) {
					totalFine = totalFine.add(FINE_PER_DAY.multiply(BigDecimal.valueOf(overdueDays)));
				}
			}
		}

		if (totalFine.compareTo(BigDecimal.ZERO) <= 0) {
			log.info("No overdue books for member ID: {}", memberId);
			return FineDTO.builder()
					.fineId(null)
					.memberId(memberClient.getMemberById(memberId))
					.amount(BigDecimal.ZERO)
					.status("NO_FINE")
					.transactionDate(null)
					.message("‚úÖ You have no fines to pay. All books were returned on time!")
					.build();
		}

		Fine fine = Fine.builder()
				.memberId(memberId)
				.amount(totalFine)
				.status(Fine.FineStatus.PENDING)
				.transactionDate(LocalDate.now())
				.build();

		fineRepository.save(fine);

		return mapToDTO(fine);
	}

	@Override
	public FineDTO payFine(Long memberId, Long fineId) {
		log.info("Processing payment for fine ID: {} by member ID: {}", fineId, memberId);

		Fine fine = fineRepository.findById(fineId)
				.orElseThrow(() -> new FineNotFoundException("Fine not found with ID: " + fineId));

		if (!fine.getMemberId().equals(memberId)) {
			throw new UnauthorizedAccessException("üö´ You are not authorized to pay this fine.");
		}

		if (fine.getStatus() == Fine.FineStatus.PAID) {
			throw new RuntimeException("‚ÑπÔ∏è This fine is already paid.");
		}

		fine.setStatus(Fine.FineStatus.PAID);
		fineRepository.save(fine);

		log.info("‚úÖ Fine ID {} paid successfully by member {}", fineId, memberId);
		return mapToDTO(fine);
	}

	@Override
	public List<FineDTO> getAllFines() {
		log.info("Fetching all fines (admin view)");
		return fineRepository.findAll().stream()
				.map(this::mapToDTO)
				.collect(Collectors.toList());
	}

	@Override
	public List<FineDTO> getFinesByMemberId(Long memberId) {
		log.info("Fetching fines for member ID: {}", memberId);
		return fineRepository.findByMemberId(memberId).stream()
				.map(this::mapToDTO)
				.collect(Collectors.toList());
	}

	private long calculateOverdueDays(LocalDate dueDate, LocalDate returnDate) {
		if (returnDate != null && returnDate.isAfter(dueDate)) {
			return java.time.temporal.ChronoUnit.DAYS.between(dueDate, returnDate);
		}
		return 0;
	}

	private FineDTO mapToDTO(Fine fine) {
		return FineDTO.builder()
				.fineId(fine.getFineId())
				.memberId(memberClient.getMemberById(fine.getMemberId()))
				.amount(fine.getAmount())
				.status(fine.getStatus().name())
				.transactionDate(fine.getTransactionDate())
				.message("‚úÖ Fine details retrieved successfully.")
				.build();
	}
}


